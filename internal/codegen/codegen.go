package codegen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/fatih/color"
	"gopkg.in/yaml.v3"
)

// APISpec 定义 API 规范结构
type APISpec struct {
	Endpoint    string   `yaml:"endpoint"`
	Method      string   `yaml:"method"`
	Summary     string   `yaml:"summary"`
	Auth        any      `yaml:"auth"` // bool or string (e.g., "admin")
	Description string   `yaml:"description"`
	Request     Request  `yaml:"request"`
	Response    Response `yaml:"response"`
}

// Request 定义请求结构
type Request struct {
	ContentType string  `yaml:"content_type"`
	Fields      []Field `yaml:"fields"`
}

// Response 定义响应结构
type Response struct {
	Success SuccessResponse `yaml:"success"`
	Errors  []ErrorResponse `yaml:"errors"`
}

// SuccessResponse 定义成功响应
type SuccessResponse struct {
	Status int     `yaml:"status"`
	Fields []Field `yaml:"fields"`
}

// ErrorResponse 定义错误响应
type ErrorResponse struct {
	Status      int    `yaml:"status"`
	Error       string `yaml:"error"`
	Code        string `yaml:"code"`
	Description string `yaml:"description"`
}

// Field 定义字段结构
type Field struct {
	Name        string  `yaml:"name"`
	Type        string  `yaml:"type"`
	Required    bool    `yaml:"required"`
	Description string  `yaml:"description"`
	Example     any     `yaml:"example"`
	Fields      []Field `yaml:"fields"` // 嵌套字段
}

// Generator 代码生成器
type Generator struct {
	SpecDir string
	Lang    string
	Output  string
}

// Generate 生成代码
func (g *Generator) Generate(service string) error {
	specPath := filepath.Join(g.SpecDir, service)
	if _, err := os.Stat(specPath); os.IsNotExist(err) {
		return fmt.Errorf("service spec not found: %s", specPath)
	}

	// 收集所有 API 规范
	specs, err := g.collectSpecs(specPath)
	if err != nil {
		return err
	}

	color.Cyan("Found %d API specs in %s", len(specs), service)

	// 根据语言生成代码
	switch g.Lang {
	case "go":
		return g.generateGo(service, specs)
	case "typescript", "ts":
		return g.generateTypeScript(service, specs)
	default:
		return fmt.Errorf("unsupported language: %s (supported: go, typescript)", g.Lang)
	}
}

func (g *Generator) collectSpecs(dir string) (map[string]*APISpec, error) {
	specs := make(map[string]*APISpec)

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() || !strings.HasSuffix(path, ".yaml") {
			return nil
		}

		data, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		var spec APISpec
		if err := yaml.Unmarshal(data, &spec); err != nil {
			color.Yellow("  [skip] %s: %v", path, err)
			return nil
		}

		// 跳过没有 endpoint 的文件（如 meta.yaml）
		if spec.Endpoint == "" {
			return nil
		}

		relPath, _ := filepath.Rel(dir, path)
		name := strings.TrimSuffix(relPath, ".yaml")
		name = strings.ReplaceAll(name, "/", "_")
		specs[name] = &spec

		return nil
	})

	return specs, err
}

func (g *Generator) generateGo(service string, specs map[string]*APISpec) error {
	if err := os.MkdirAll(g.Output, 0755); err != nil {
		return err
	}

	// 生成类型定义
	typesFile := filepath.Join(g.Output, "types.go")
	f, err := os.Create(typesFile)
	if err != nil {
		return err
	}
	defer f.Close()

	pkgName := strings.ReplaceAll(service, "-", "")
	fmt.Fprintf(f, "// Code generated by sm codegen. DO NOT EDIT.\n")
	fmt.Fprintf(f, "package %s\n\n", pkgName)

	for name, spec := range specs {
		structName := toPascalCase(name)

		// Request struct
		if len(spec.Request.Fields) > 0 {
			fmt.Fprintf(f, "// %sRequest %s\n", structName, spec.Summary)
			fmt.Fprintf(f, "type %sRequest struct {\n", structName)
			for _, field := range spec.Request.Fields {
				g.writeGoField(f, field, "\t")
			}
			fmt.Fprintf(f, "}\n\n")
		}

		// Response struct
		if len(spec.Response.Success.Fields) > 0 {
			fmt.Fprintf(f, "// %sResponse %s\n", structName, spec.Summary)
			fmt.Fprintf(f, "type %sResponse struct {\n", structName)
			for _, field := range spec.Response.Success.Fields {
				g.writeGoField(f, field, "\t")
			}
			fmt.Fprintf(f, "}\n\n")
		}
	}

	color.Green("  [generated] %s", typesFile)
	return nil
}

func (g *Generator) writeGoField(f *os.File, field Field, indent string) {
	goType := g.toGoType(field.Type)
	jsonTag := field.Name
	if !field.Required {
		jsonTag += ",omitempty"
	}

	if field.Type == "object" && len(field.Fields) > 0 {
		// 内联结构体
		fmt.Fprintf(f, "%s%s struct {\n", indent, toPascalCase(field.Name))
		for _, subField := range field.Fields {
			g.writeGoField(f, subField, indent+"\t")
		}
		fmt.Fprintf(f, "%s} `json:\"%s\"`", indent, jsonTag)
	} else {
		fmt.Fprintf(f, "%s%s %s `json:\"%s\"`", indent, toPascalCase(field.Name), goType, jsonTag)
	}

	if field.Description != "" {
		fmt.Fprintf(f, " // %s", field.Description)
	}
	fmt.Fprintf(f, "\n")
}

func (g *Generator) toGoType(t string) string {
	switch t {
	case "string":
		return "string"
	case "integer", "int":
		return "int"
	case "uint64":
		return "uint64"
	case "boolean", "bool":
		return "bool"
	case "object":
		return "map[string]any"
	case "array":
		return "[]any"
	default:
		return "any"
	}
}

func (g *Generator) generateTypeScript(service string, specs map[string]*APISpec) error {
	if err := os.MkdirAll(g.Output, 0755); err != nil {
		return err
	}

	// 生成类型定义
	typesFile := filepath.Join(g.Output, "types.ts")
	f, err := os.Create(typesFile)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by sm codegen. DO NOT EDIT.\n\n")

	for name, spec := range specs {
		typeName := toPascalCase(name)

		// Request interface
		if len(spec.Request.Fields) > 0 {
			fmt.Fprintf(f, "/** %s */\n", spec.Summary)
			fmt.Fprintf(f, "export interface %sRequest {\n", typeName)
			for _, field := range spec.Request.Fields {
				g.writeTSField(f, field, "  ")
			}
			fmt.Fprintf(f, "}\n\n")
		}

		// Response interface
		if len(spec.Response.Success.Fields) > 0 {
			fmt.Fprintf(f, "/** %s */\n", spec.Summary)
			fmt.Fprintf(f, "export interface %sResponse {\n", typeName)
			for _, field := range spec.Response.Success.Fields {
				g.writeTSField(f, field, "  ")
			}
			fmt.Fprintf(f, "}\n\n")
		}
	}

	color.Green("  [generated] %s", typesFile)
	return nil
}

func (g *Generator) writeTSField(f *os.File, field Field, indent string) {
	tsType := g.toTSType(field.Type)
	optional := ""
	if !field.Required {
		optional = "?"
	}

	if field.Description != "" {
		fmt.Fprintf(f, "%s/** %s */\n", indent, field.Description)
	}

	if field.Type == "object" && len(field.Fields) > 0 {
		fmt.Fprintf(f, "%s%s%s: {\n", indent, field.Name, optional)
		for _, subField := range field.Fields {
			g.writeTSField(f, subField, indent+"  ")
		}
		fmt.Fprintf(f, "%s};\n", indent)
	} else {
		fmt.Fprintf(f, "%s%s%s: %s;\n", indent, field.Name, optional, tsType)
	}
}

func (g *Generator) toTSType(t string) string {
	switch t {
	case "string":
		return "string"
	case "integer", "int", "uint64":
		return "number"
	case "boolean", "bool":
		return "boolean"
	case "object":
		return "Record<string, any>"
	case "array":
		return "any[]"
	default:
		return "any"
	}
}

// ListServices 列出所有可用的服务
func ListServices(specDir string) ([]string, error) {
	entries, err := os.ReadDir(specDir)
	if err != nil {
		return nil, err
	}

	var services []string
	for _, entry := range entries {
		if entry.IsDir() && !strings.HasPrefix(entry.Name(), ".") {
			services = append(services, entry.Name())
		}
	}
	return services, nil
}

func toPascalCase(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == '/'
	})
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
